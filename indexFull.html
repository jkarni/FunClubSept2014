<!DOCTYPE html>
<!-- AUTOGENERATED! DO NOT EDIT! -->
<html>
  <head>
    <title>FunClubSept2014</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">


<!-- #Julian# -->

# Overview

- Contracts
    * Soft Contract Verification, P. Nguyên et al.
- Deep and shallow DSL embeddings
    * Folding Domain-Specific Languages, J. Gibbons and N. Wu
- Reflection without remorse
    * Reflection Without Remorse, A. van der Ploeg and O. Kiselyov

   
---
name: contract-demo
layout: false
 
# Contracts


```racket
(succ : pos? -> pos?) ;; contract
(define (succ x)
    (+ x 1))
```
--
                 |    |
      succ       |    |      x
                 |    | 

---
template: contract-demo

                 |    |
      succ       |    |  <-  x
                 |    | 

---
template: contract-demo
 
                 |    |
      succ       | x  | 
                 |    | 

---
template: contract-demo
  
                 |    |
      succ       | x  | 
                 |    | 
                   ^---- (pos? x)

---
template: contract-demo
  
                 |    |
      succ       | x  | 
                 |    | 
                   ^---- (false)

---
template: contract-demo
  
                 |    |
      succ       | x  | 
                 |    | 
                   ^---- (false) BLAME CONTEXT

---
template: contract-demo
  
                 |    |
      succ       | x  | 
                 |    | 
                   ^---- (pos? x)
                   
---
template: contract-demo
  
                 |    |
      succ       | x  | 
                 |    | 
                   ^---- (true)
---
template: contract-demo
  
                 |    |
      succ     x |    | 
                 |    | 
 
---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 

---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 
        ^--- (pos? (succ x))

---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 
        ^--- (false)

---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 
        ^--- (false)   BLAME succ
---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 
        ^--- (pos? (succ x))

---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 
        ^--- (true)

---
template: contract-demo
  
                 |    |
      succ x     |    | 
                 |    | 
        ^--- (true)   CARRY ON

---
name:static-checking

## Static checking


---
template: static-checking

```racket
(f : pos? -> neg?) ;; contract
(define (f x)
    (* x -1))
```
---
template: static-checking

```racket
(f : pos? -> neg?) ;; contract
(* x -1))
```

---
template: static-checking

```racket
(f : pos? -> neg?) ;; contract
(* x -1))
```
'x' can be assumed to be positive

---
template: static-checking

```racket
(f : pos? -> neg?) ;; contract
(* {pos} -1))
```

---
template: static-checking

```racket
(f : pos? -> neg?) ;; contract
(* {pos} -1))
```
Fact: `* -1` {pos} -> {neg}

---
template: static-checking

```racket
(f : pos? -> neg?) ;; contract
({neg})
```

---
name: higher-order

But what about higher-orders? 

---
template: higher-order

```racket
(e2o : (even? -> even?) -> (odd? -> odd?)
(define (e2o f)
 (lambda (n) (- (f (+ n 1)) 1)))
```
 
-- 

> The key insight is that contracts delay higher-order checks and failures
> always occur with a first order witness.
 
  
--

Just keep the boundary checking inside the higher-order function.

---
name: proof
```racket
(e2o : (even? -> even?) -> (odd? -> odd?)
(define (e2o f)
 (lambda (n) (- (f (+ n 1)) 1)))
```
---
template: proof

Can assume:
- `(f : even? -> even?)`

---
template: proof

Can assume:
- `(f : even? -> even?)`


Must prove:
- `f` is called with `x: even?`

---
template: proof

Can assume:
- `(f : even? -> even?)`



Must prove:
- `f` is called with `x: even?`

---
template: proof

Can assume:
- `(f : even? -> even?)`
- `(n : odd?)`


Must prove:
- `f` is called with `x: even?`

---
template: proof

Can assume:
- `(f : even? -> even?)`
- `(n : odd?)`
- `(+ : {odd?} 1) -> {even?}` 

Must prove:
- `f` is called with `x: even?`

---
template: proof

Can assume:
- `(f : even? -> even?)`
- `((+ n 1) : even?)`

Must prove:
- `f` is called with `x: even?`

---
template: proof

Can assume:
- `(f : even? -> even?)`
- `((+ n 1) : even?)`

Must prove:
- `f` is called with `x: even?` - DONE

---
template: proof

Can assume:
- `(f : even? -> even?)`
- `((+ n 1) : even?)`

---
template: proof

Can assume:
- `(f (+ n 1) : even?)`

---
template: proof

Can assume:
- `(f (+ n 1) : even?)`
- `(- : {even?} 1) -> odd?`

---
template: proof

Can assume:
- `(- (f (+ n 1)) 1) : odd?)`

---
template: proof

Can assume:
- `(- (f (+ n 1)) 1) : odd?)`

DONE

---
name: deep-and-shallow
# Deep and Shallow Embeddings


---
template: deep-and-shallow

## Deep

```haskell
data Exp :: * where
    Lit :: Int -> Exp
    Add :: Exp -> Exp -> Exp

evalD (Lit x)    = x
evalD (Plus x y) = evalD x + evalD y
```

--

## Shallow

```haskell
type Exp = Int

lit n = n
add x y = x + y

evalS :: Exp -> Int
evalS = id
```
        
---
template: deep-and-shallow

Deep and shallow embeddings as duals:

--

- Lit and Add do none of the work, evalD all of it.

--

- lit and add do all of the work, evalS is just id.

--

- Easy to add other 'evaluators' to deep (such as pretty-printing).

--

- Hard to do the same for shallow.

--

- Hard to add another construct to deep.

--

- Easy to do the same for shallow.

--

The expression problem. 

---

## Folds and Multiple interpretations


How do we get multiple interpretations for shallow embeddings?

-- 

```haskell
type Exp = (Int, String)

lit n = (n, show n)
add x y = (x + y, show x ++ " + " ++ show y)

evalSInt :: Exp -> Int
evalSInt = fst

evalSShow :: Exp -> Show
evalSShow = snd
```

--
But what if we don't want to commit ahead of time to the ways in which we will
interpret the data?

---

## Reflection without Remorse


Lists as our running analogy:

- List append efficiency depends on associativity of operation.
    * Solution: difference lists
        - [1,2,3] ==> \xs -> [1,2,3] ++ xs
        - [1,2,3] ++ [4,5,6] ==> (\xs -> [1,2,3] ++ xs) . (\ys -> [4,5,6] ++ ys)
        -                    ==> (\zs -> [1,2,3] ++ ([4,5,6] ++ zs))
    * But now 'observing' the list is expensive.
    * Solution: Okasaki's bootstrapped data types.

---
layout: false

Observation: Monads often have this property (associativity changes
performance). 
- Example: Free Monads

```haskell
data Free f r = Free (f (Free f r)) | Pure r
instance (Functor f) => Monad (Free f) where
    return = Pure
    (Free x) >>= f = Free (fmap (>>= f) x)
    (Pure r) >>= f = f r
```
--
So
```
x >>= f >>= g = g (f x)
Free a >>= f >>= g = Free (fmap (>>= f) x) >>= g
Free a >>= f >>= g = Free (fmap (>>= g) (fmap (>>= f) x)))
Free a >>= (f . g) = Free (fmap (>>= f . g) x)
```
 
Can we apply the same tricks to them?



---
<!-- #Matthias# -->

# Overview

- Ivory and Tower
- Haste
- ghcjs


---

# Ivory and Tower
--

## An experience report

- Autopilot for a military helicopter
- Deadline: 18 months
- http://dl.acm.org/citation.cfm?id=2628146&CFID=559949482&CFTOKEN=36745757

--

## Strategy

1. Design two new embedded programming languages from scratch
    - (14 person months)
--
2. Use these languages to write the actual code
    - (22 person months)

---

## Ivory

- Generates C-code
- EDSL itself is very restrictive (but Turing-complete)
- Use Haskell as macro system
- 6k lines of Haskell code

---

## Ivory

```haskell
[ivory|
struct fooStruct
  { bar :: Stored Uint8
  ; baz :: Array 10 (Stored Sint16)
  }
|]

setBaz :: Def ([Ref Global (Struct "fooStruct"), Sint16] :-> ())
setBaz = proc "setBaz" $ \ ref val -> body (prgm ref val)

prgm :: Ref Global (Struct "fooStruct") -> Sint16 -> Ivory eff ()
prgm ref val = arrayMap $ \ ix -> store ((ref ~> baz) ! ix) val
```

--

```haskell
cmodule :: Module
cmodule = package "foo_mod" $ do
    defStruct (Proxy :: Proxy "fooStruct")
    incl setBaz

main :: IO ()
main = void $ runCompiler [cmodule] initialOpts
```

---

## Ivory

foo_module.h:
```c
struct fooStruct {
    uint8_t bar;
    int16_t baz[10U];
};

void setBaz(struct fooStruct* n_var0, int16_t n_var1);
```
--

foo_source.c:
```c
#include "foo_module.h"

void setBaz(struct fooStruct* n_var0, int16_t n_var1) {
    for ( int32_t n_ix0 = (int32_t) 0
        ; n_ix0 <= (int32_t) 9
        ; n_ix0++ ) {
        n_var0->baz[n_ix0] = n_var1;
    }
}
```

---

## Ivory: Compiler error messages

```haskell
setBaz :: Def ([Ref Global (Struct "fooStruct"), Sint16] :-> ())
setBaz = proc "setBaz" $ \ ref val -> body (prgm ref val)
```

---

## Ivory: Compiler error messages

```haskell
setBaz :: Def ([Ref Global (Struct "fooStruct"), Sint16] :-> ())
setBaz = proc "setBaz" $ \ ref val _ -> body (prgm ref val)
```

--

```haskell
/mnt/slig-sda3/home/mf/fungroup/ivory.hs:89:10:
    No instance for (Ivory.Language.Proc.IvoryProcDef
                       ('[] ':-> ()) (t0 -> Body r0))
      arising from a use of ‘proc’
    In the expression: proc "setBaz"
    [...]

/mnt/slig-sda3/home/mf/fungroup/ivory.hs:89:41:
    No instance for (IvoryType r0) arising from a use of ‘body’
    The type variable ‘r0’ is ambiguous
    Note: there are several potential instances:
      instance (Ivory.Language.BitData.Bits.IvoryRep (BitRep n)) =>
               IvoryType (Bits n)
        -- Defined in ‘Ivory.Language.BitData.Bits’
      instance IvoryType Uint16 -- Defined in ‘Ivory.Language.Uint’
      instance IvoryType Uint32 -- Defined in ‘Ivory.Language.Uint’
      ...plus 19 others
    In the expression: body (prgm ref val)
    [...]
```

---

## Ivory

Guarantees:

- Type-level array lengths!  (-:
- Well-typed, well-scoped memory management
- Well-typed C structs
- Well-typed register / bit fields
- No nullable pointers
- No pointer arithmetic
- No void pointer
- No unsafe casts

http://github.com/GaloisInc/ivory/blob/master/ivory/user-guide.md


---

## Tower

- Ivory extension
- tasks (~ threads or processes)
- communication channels
- multiple backends (RTOSes, theorem provers, Graphviz)
- 3k lines of Haskell code

![Default-aligned image](fig3-tower.png)

---

## Lessons Learned

- SMACCMPilot is 23kloc Ivory, Tower (48kloc C compiled)
- Still uses some ArduPilot code
--

- Types are awesome
--

- Bugs in the C backend are easy to work around (robust!)
--

- Bugs in Ivory, Tower are easy to fix
--

- Bad habits can be outlawed by changing the language


---

# Haste
--

## seamless web application programming

- write both server and client code in haskell
- data types and application logic exist *only once*
- communicate via RPC (currently: web sockets)

https://github.com/valderman/haste-compiler

(Independent, similar project: https://github.com/takeoutweight/shade)


---

## example

```haskell
app = do
    remoteref <- liftServerIO $ newIORef 0

    count <- remote $ do
        r <- remoteref
        liftIO $ atomicModifyIORef r (\ v -> (v+1, v+1))

    runClient $ do
        visitors <- onServer count
        alert ("Your are visitor #" ++ show visitors)
```

--

```haskell
main :: IO ()
main = runApp (mkConfig "ws://localhost:1111" 1111) app
```


---

# ghcjs


---

## The ICFP programming contest

![Default-aligned image](fig0-lambdaman.png)


---

## The ICFP programming contest

![Default-aligned image](fig1-lambdaman.png)


---

## The ICFP programming contest

![Default-aligned image](fig2-lambdaman.png)

http://icfpcontest.org/

http://icfpcontest.org/game.html


---

# ghcjs

- links against ghclib
- several new js-specific compiler phases
- template haskell runs on node.js!
- in-browser, real-time profiling!
- Efficient GHC runtime threads (`forkIO`)


--

## Performance

- lambdaman simulator: runtime is down to a factor of 20 relative to native
- 367k js code includes runtime, libs, application (minified, zipped)
- runtime alone is at 60k (un-minified, un-zipped source: 800k)
- improving rapidly


---

# ghcjs

## DOM lib

```haskell
import GHCJS.DOM
import GHCJS.DOM.Document
import GHCJS.DOM.HTMLElement

main = runWebGUI $ \ webView -> do
    Just doc <- webViewGetDomDocument webView
    Just body <- documentGetBody doc
    htmlElementSetInnerHTML body ("<p>hello world!</p>")
```


---

# ghcjs

## FFI

```haskell
{-# LANGUAGE JavaScriptFFI, CPP #-}

module Main where

#ifdef __GHCJS__
foreign import javascript unsafe "document.write($1+'<br/>');"
    writeNumber :: Int -> IO ()
foreign import javascript safe   "setTimeout($c, $1);"
    delay       :: Int -> IO ()
#else
writeNumber = error "writeNumber: only available from JavaScript"
delay = error "delay: only available from JavaScript"
#endif

main :: IO ()
main = mapM_ (\x -> writeNumber x >> delay 1000) [1..1000]
```


---

# ghcjs

## FFI

```haskell
x :: Int -> JSRef a -> IO ()
```

```javascript
var x = 5;
var y = h$c1(h$ghcjszmprimZCGHCJSziPrimziJSRef_con_e, o)
var action = h$c3(h$ap2_e, h$MainZCMainzix, x, y);
h$runSync(action, false);
```


---

## There is much more!

- code: https://github.com/ghcjs/ghcjs
- HIW talk: http://www.youtube.com/watch?v=pXBJc4e9KIE
- blog article (June 2013): http://weblog.luite.com/wordpress/?p=14
- blaze/react (brand new / alpha!): https://github.com/meiersi/blaze-react



---

# Thank you


    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
